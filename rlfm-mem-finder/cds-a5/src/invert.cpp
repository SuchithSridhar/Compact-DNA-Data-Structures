#include <sdsl/int_vector.hpp>
#include <sdsl/sd_vector.hpp>
#include <sdsl/rank_support.hpp>
#include <sdsl/bit_vectors.hpp>

#include <vector>
#include <string>

#define CHAR_COUNT 256

int n = 0;
int r = 0;
int sigma = 0;

// all the characters in T or BWT(T)
std::vector<unsigned char> alphabet;

// to map a character to the index
// Ex. #:0, $:1, A:2, C:3, G:4, T:5
std::vector<int> char_to_index;

// The data structures needed for the assignment
sdsl::sd_vector B_F_sparse;
sdsl::sd_vector B_L_sparse;

std::vector<int> C;
std::vector<char> H_L;
std::vector<std::unique_ptr<sdsl::bit_vector> > B_x;

// Rank and Select data structures on B_F and B_L
sdsl::rank_support_sd<> rank_B_L;
sdsl::select_support_sd<> select_B_L;
sdsl::rank_support_sd<> rank_B_F;
sdsl::select_support_sd<> select_B_F;

// Rank data structure for B_x bit vectors
std::vector<std::unique_ptr<sdsl::rank_support_v< > > > B_x_ranks;


void deserialize_data(char *inputFileName) {
    std::ifstream in_file(inputFileName, std::ios::in | std::ios::binary);

    in_file.read(reinterpret_cast<char*>(&n), sizeof(n));
    in_file.read(reinterpret_cast<char*>(&r), sizeof(r));
    in_file.read(reinterpret_cast<char*>(&sigma), sizeof(sigma));
    std::cerr << "n: " << n << "\n";
    std::cerr << "r: " << r << "\n";
    std::cerr << "sigma: " << sigma << "\n";

    H_L.resize(r);
    in_file.read(reinterpret_cast<char*>(&H_L[0]), r*sizeof(H_L[0]));

    C.resize(sigma);
    in_file.read(reinterpret_cast<char*>(&C[0]), sigma*sizeof(C[0]));

    alphabet.resize(sigma);
    in_file.read(reinterpret_cast<char*>(&alphabet[0]), sigma*sizeof(alphabet[0]));
    std::cerr << "\nThe alphabet in the BWT:\n";
    for (int i = 0; i < sigma; i++)
        std::cerr << "\t" << i << " -> " << static_cast<int>(alphabet[i]) << "(" << alphabet[i] << ")\n";
    std::cerr << "\n";
    char_to_index.resize(CHAR_COUNT);
    in_file.read(reinterpret_cast<char*>(&char_to_index[0]), CHAR_COUNT*sizeof(char_to_index[0]));

    B_L_sparse.load(in_file);

    // Building the rank and select data structures for querying B_L
    rank_B_L = sdsl::rank_support_sd<>(&B_L_sparse); // usage example: rank_B_L(i) gives the rank result at index i on B_L
    select_B_L = sdsl::select_support_sd<>(&B_L_sparse); // usage example: select_B_L(i) gives the select result at index i on B_L

    B_F_sparse.load(in_file);

    // Building the rank and select data structures for querying B_L
    rank_B_F = sdsl::rank_support_sd<>(&B_F_sparse); // usage example: rank_B_L(i) gives the rank result at index i on B_L
    select_B_F = sdsl::select_support_sd<>(&B_F_sparse); // usage example: select_B_L(i) gives the select result at index i on B_L

    for (int i = 0; i < sigma; i++) {
        auto new_b_vector = std::make_unique<sdsl::bit_vector>();
        new_b_vector->load(in_file);
        B_x.push_back(std::move(new_b_vector));
    }

    // create the rank objects for the B_x bit vectors
    for (auto& B: B_x) {
        B_x_ranks.emplace_back(std::unique_ptr<sdsl::rank_support_v< > >(new sdsl::rank_support_v< >(B.get())));
    }
    // Example: code to perform rank query on B_2 at position 10:
    // std::cerr << (*B_x_ranks[2])(10) << "\n";

    in_file.close();
}

typedef struct {
    long i;
    char X;
} LF_result_t;

LF_result_t LF(long i) {
    int run = rank_B_L(i + 1) - 1;
    int offset = i - select_B_L(run + 1);

    char mapped_char = H_L[run];
    char X = char_to_index[mapped_char];

    long pred_x = (*B_x_ranks[X])(run);

    int run_f = C[X] + pred_x;
    long pos_f = select_B_F(run_f + 1) + offset;

    std::cout << "i: " << i
              << ", run: " << run
              << ", offset: " << offset
              << ", mapped_char: " << mapped_char
              << ", X: " << X
              << ", pred_x: " << pred_x
              << ", run_f: " << run_f
              << ", pos_f: " << pos_f
              << std::endl;
    
    return {.i = pos_f, X = mapped_char};
}


void invert_bwt() {
    LF_result_t r = {
        .i = 0,
        .X = 0
    };

    do
    {
        r = LF(r.i);
        // std::cout << r.X;
    } while (r.i != 0);
}

int main(int argc, char** argv) {
    std::cerr << "usage: load DATASET.ri\n";
    std::cerr << "The DATASET.ri is generated by the build script.\n\n";

    deserialize_data(argv[1]);
    std::cerr << "All the arrays and bit vectors are loaded.\n\n";

    invert_bwt();   
}