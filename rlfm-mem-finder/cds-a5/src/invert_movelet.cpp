#include <sdsl/bit_vectors.hpp>
#include <sdsl/int_vector.hpp>
#include <sdsl/rank_support.hpp>
#include <sdsl/sd_vector.hpp>

#include <string>
#include <vector>

#define CHAR_COUNT 256

int n = 0;
int r = 0;
int sigma = 0;

// all the characters in T or BWT(T)
std::vector<unsigned char> alphabet;

// to map a character to the index
// Ex. #:0, $:1, A:2, C:3, G:4, T:5
std::vector<int> char_to_index;

// The data structures needed for the assignment
sdsl::sd_vector B_F_sparse;
sdsl::sd_vector B_L_sparse;

std::vector<int> C;
std::vector<char> H_L;
std::vector<std::unique_ptr<sdsl::bit_vector>> B_x;

// Rank and Select data structures on B_F and B_L
sdsl::rank_support_sd<> rank_B_L;
sdsl::select_support_sd<> select_B_L;
sdsl::rank_support_sd<> rank_B_F;
sdsl::select_support_sd<> select_B_F;

// Rank data structure for B_x bit vectors
std::vector<std::unique_ptr<sdsl::rank_support_v<>>> B_x_ranks;

sdsl::bit_vector B_FL;
sdsl::select_support_mcl<> select_B_FL;

void deserialize_data(char *inputFileName) {
  std::ifstream in_file(inputFileName, std::ios::in | std::ios::binary);

  in_file.read(reinterpret_cast<char *>(&n), sizeof(n));
  in_file.read(reinterpret_cast<char *>(&r), sizeof(r));
  in_file.read(reinterpret_cast<char *>(&sigma), sizeof(sigma));
  std::cerr << "n: " << n << "\n";
  std::cerr << "r: " << r << "\n";
  std::cerr << "sigma: " << sigma << "\n";

  H_L.resize(r);
  in_file.read(reinterpret_cast<char *>(&H_L[0]), r * sizeof(H_L[0]));

  C.resize(sigma);
  in_file.read(reinterpret_cast<char *>(&C[0]), sigma * sizeof(C[0]));

  alphabet.resize(sigma);
  in_file.read(reinterpret_cast<char *>(&alphabet[0]),
               sigma * sizeof(alphabet[0]));
  std::cerr << "\nThe alphabet in the BWT:\n";
  for (int i = 0; i < sigma; i++)
    std::cerr << "\t" << i << " -> " << static_cast<int>(alphabet[i]) << "("
              << alphabet[i] << ")\n";
  std::cerr << "\n";
  char_to_index.resize(CHAR_COUNT);
  in_file.read(reinterpret_cast<char *>(&char_to_index[0]),
               CHAR_COUNT * sizeof(char_to_index[0]));

  B_L_sparse.load(in_file);

  // Building the rank and select data structures for querying B_L
  rank_B_L =
      sdsl::rank_support_sd<>(&B_L_sparse); // usage example: rank_B_L(i) gives
                                            // the rank result at index i on B_L
  select_B_L = sdsl::select_support_sd<>(
      &B_L_sparse); // usage example: select_B_L(i) gives the select result at
                    // index i on B_L

  B_F_sparse.load(in_file);

  // Building the rank and select data structures for querying B_L
  rank_B_F =
      sdsl::rank_support_sd<>(&B_F_sparse); // usage example: rank_B_L(i) gives
                                            // the rank result at index i on B_L
  select_B_F = sdsl::select_support_sd<>(
      &B_F_sparse); // usage example: select_B_L(i) gives the select result at
                    // index i on B_L

  for (int i = 0; i < sigma; i++) {
    auto new_b_vector = std::make_unique<sdsl::bit_vector>();
    new_b_vector->load(in_file);
    B_x.push_back(std::move(new_b_vector));
  }

  // create the rank objects for the B_x bit vectors
  for (auto &B : B_x) {
    B_x_ranks.emplace_back(std::unique_ptr<sdsl::rank_support_v<>>(
        new sdsl::rank_support_v<>(B.get())));
  }
  // Example: code to perform rank query on B_2 at position 10:
  // std::cerr << (*B_x_ranks[2])(10) << "\n";

  B_FL.load(in_file);
  select_B_FL = sdsl::select_support_mcl<>(&B_FL);

  in_file.close();
}

typedef struct {
  int run;
  int offset;
  char X;
} LF_result_t;

LF_result_t LF(int run, int offset) {

  char mapped_char = H_L[run];
  char X = char_to_index[mapped_char];

  long pred_x = (*B_x_ranks[X])(run);

  int run_f = C[X] + pred_x;

  long pos_f = select_B_F(run_f + 1) + offset;

  int b = select_B_FL(run_f + 1); // run_f in B_FL
  int l = b - run_f - 1;          // number of 0s till run_f

  long l_pos = l + 1 <= r ? select_B_L(l + 1) : n;
  long l_next_pos = l + 2 <= r ? select_B_L(l + 2) : n;

  while (!(l_pos <= pos_f && pos_f < l_next_pos)) {
    // while pos_f doesn't lie in current run, move to next run.
    l++;
    l_pos = l_next_pos;
    l_next_pos = l + 2 <= r ? select_B_L(l + 2) : n;
  }

  return {
      .run = l,
      .offset = (int)(pos_f - l_pos),
      .X = mapped_char,
  };
}

void invert_bwt() {
  LF_result_t r = {
      .run = 0,
      .offset = 0,
      .X = 0,
  };

  do {
    r = LF(r.run, r.offset);
    std::cout << r.X;
  } while (!(r.run == 0 && r.offset == 0));
}

int main(int argc, char **argv) {
  std::cerr << "usage: load DATASET.ri\n";
  std::cerr << "The DATASET.ri is generated by the build script.\n\n";

  deserialize_data(argv[1]);
  std::cerr << "All the arrays and bit vectors are loaded.\n\n";

  invert_bwt();
}
